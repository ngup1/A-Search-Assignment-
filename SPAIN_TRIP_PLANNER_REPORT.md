# A* Search Algorithm Analysis Report - Spain Weekend Trip Planner

## Problem Description

As I begin to travel, I thought it would be a good idea to implement an A* search to solve a trip planning problem. The problem is about finding the optimal route for a weekend trip from Madrid that visits multiple Spanish cities. In this case we run an example with Toledo and Cordoba. I modeled this as a graph search problem where we start at MADRID and need to visit both TOLEDO and CORDOBA, minimizing total driving time. The graph I created has the cities Madrid, Toledo, Segovia, Avila, Cuenca, Salamanca, Cordoba, and Valencia. Each connection between cities has a cost that represents the actual driving time in hours. I used the manhatten distance formula to calculate straight-line distances between cities based on their latitude and longitude coordinates, then converted those to driving hours. The heuristic function h(n) calculates the estimated driving hours to the nearest goal city using the same manhattan distance formula. There is a potential issue to consider in this implementation that the driving times are considered as straight lines, whereas roads are hardly ever straight lines. This may deem the heuristic function inadmissable if they underesitmate the driving time. What makes this problem challenging is that it's a multi-goal problem. Instead of just finding a path to one goal and terminating, I needed to find a way to visit ALL goals in the entered goals list. To accomplish this, I implemented a function that gathers all possible permutations of goal orders (function taken from Leetcode problem "Permutations")  picks the shortest overall route using A*, or any other algorithm passed in. For two goals, that means trying both TOLEDO → CORDOBA and CORDOBA → TOLEDO and seeing which order gives the shorter total driving time.

## Computed Values: Actual Costs and h(n)

All three algorithms found the same optimal path, which was MADRID → TOLEDO → CORDOBA with a total driving time of 4.0 hours.

- USC explored 10 cities total. UCS only uses g(n) for its priority function, so it systematically explores based on actual driving time. Looking at the actual costs starting at MADRID, g(n) is 0.00 hours. Then at TOLEDO, the actual cost g(n) is 1.00 hours (the driving time from Madrid). Finally at CORDOBA, g(n) is 4.00 hours total (1.0 from Madrid to Toledo + 3.0 from Toledo to Cordoba).

- GBFS found the exact same path but only explored 4 cities, which is much more efficient. Greedy only uses h(n) for its priority function. So it's following whatever city looks closest to the goal at each step, ignoring how long it actually takes to drive there. The h(n) Values were Madrid 0.0 > Toledo 1.01 > Cordoba 0.0. 

- A* Search also found the same path and explored 4 cities like Greedy. A* uses both g(n) and h(n) combined, so its priority function is f(n) = g(n) + h(n). At MADRID, f(n) would be 0.00 + 1.01 = 1.01. At TOLEDO, it's 1.00 + 0.00 = 1.00 (since we reached the first goal).

## Comparative Analysis

All three algorithms found the same optimal path with a total driving time of 4.0 hours. The path goes MADRID > TOLEDO > CORDOBA, which makes sense because going through Toledo (1.0h + 3.0h = 4.0h total) is faster than going directly to Cordoba first (4.5h + 3.0h = 7.5h total). UCS guarantees an optimal solution because it explores nodes in order of increasing actual cost, so it will always find the shortest path eventually, even if it is less efficnent. A* also guarantees the best result as long as the heuristic is admissible, which mine in theory is. Greedy Best-First Search doesn't guarantee optimality, but in this case it happened to find the optimal path anyway given the geogragic locations of each city. There was still a big difference in efficiency though. UCS explored 10 cities while both Greedy and A* only explored 4 cities. Greedy and A* were both a little over twice as efficient as UCS. This makes sense because the manhattan distance helps them avoid exploring cities that don't look like they will work. The multi-goal aspect adds an interesting layer which would be inefficient with scale. My implementation tries all permutations of goal order. For two goals that's just 2 permutations, but for more goals i think it would grow factorially, which would be very unfortunate if you were trying to solve for a full European road trip, or more.

## Conclusions

For this specific problem, all three algorithms found the same optimal path visiting both Toledo and Cordoba. The manhattan distance worked well because it provided information about which cities were closer to the goals. A* and Greedy were much more efficient than UCS, exploring 6 fewer cities. A* would be the best choice for a real trip planning applications because you get both the optimal result and efficiency through the combination of actual cost and heuristic information. The multi-goal implementation using permutations works well for small numbers of destinations, but would become computationally expensive with many goals. It would be better to just rerun an A* from point to point I think. 
